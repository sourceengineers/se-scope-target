# Description
The SE-Scope is a library, used to visualize and log data produced by microcrontollers. 
A set of commands allow the scope to be dynamically reconfigured during runtime.
It features mutliple trigger modes, such as a continous, edge detecting as well as one shot mode.
# Building
The library uses cmake as build tool, and is therefore able to be compiled on pretty much anything.
Additionally there are pre configured project files for some supported IDE's. 

## Cmake host platform
- [\*nix systems](https://bitbucket.org/sourceengineers/iot-scope-target/src/master/doc/build-nix.md)
- [Windows](https://bitbucket.org/sourceengineers/iot-scope-target/src/master/doc/build-windows.md)
## IDE's
- [IDE's](https://bitbucket.org/sourceengineers/iot-scope-target/src/master/doc/build-ide.md)
# Usage
## Generate
For common usages such as a system communicating with UART and JSON, there are pre configured 
builders to generate the scope. 

Building the UartJson stack can be done by the following code:
```c
uint32_t timestamp = 0;
size_t channelSize = 50;
size_t amountOfChannels = 3;
size_t announceAddresses = 3;

void transmit_data(UartJsonHandle self){
  printf("Implement your transmit function here");
}

JsonUartStack_create(channelSize, amountOfChannels, transmit_data, &timestamp, announceAddresses);
```
If a stack should be used that is not pre generated, it can be custom build.
The UartJson class can be used as an example of how to do this.
## Running
To run the scope, just call the ScopeRunner with the object generated by the builder.
```c
/* Run the scope */
ScopeRunner_run(scope_obj);
```
Note, that the timestamp will not be automatically be increased. This has to be done externally.
As example through a systick on a embedded device.
## Communication
Every communication interface class should supply functions, through which data can be passed into the scope, and be read out of it.
Following examples will show how these behave with the UartJson class. Other interfaces should work similarly.
### Input
```c
UartJson_putRxData(uartJson, data, length);
```
The underlying UartJson class will accept the bytes, sanitize the input and pass the command forward if the input is ok.
### Output
When ever the trigger criteria are fulfilled, a transmit event will be triggered and the callback function will be called. This can be used to start a transmission event, or just send the data right away.
An example could look like the following code.
```c
void callback(UartJsonHandle self){
  size_t length = UartJson_amountOfTxDataPending(self);
  uint8_t data[length];
  UartJson_getTxData(self, data, length);
  UartJson_resetTx(self);  
}
```
The transmission doesn't have to happen in the callback, but can be fetched from 
the object returned from the JsonUartStack_getObject(). This might be useful if the transmission should occur in a interrupted state.

## Destroy
If the scope isn't used anymore, it can be destroyed.
Every class should supply a destroy function. Therefore everything created for the builder can be destroyed again.
```c
JsonUartStack_destroy(stack);
```

## Thread
The scope has the possibility to be run thread safe.
To the thread safe version of the scope, the IMutex interface has to be implemented for the desired operating system.
The scope can then be build with a dedicated builder and run with the thread safe runner.

```c
/* Builds the scope in a thread safe way. Mutexes have to be supplied to this function. */
void JsonUartStack_createThreadSafe(...);

/* Runs the scope in a thread safe way. This should ideally be done in a high priority thread */
JsonUartStack_runThreadScope();

/* Runs the stack in a thread safe way. This can be done in a lower priority thread */
JsonUartStack_runThreadStack();
```
# Protocol
The host and the target are communicating through a custom defined protocol.
The specification can be viewed, in the dedicated [documentation](https://bitbucket.org/sourceengineers/iot-scope-doc/src/master/Protocol.md).
# Desktop client
A desktop client which is able to control the target and display the data, is currently under work in progress.
For the moment, the developer tools in tools have to be used to communicate with the target have to be used. These will be extended before the work at the desktop client continue.
The progress of the client can be tracked in its respective [repo](https://bitbucket.org/sourceengineers/iot-scope).
# License
